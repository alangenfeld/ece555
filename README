library is set up as project_lib

current modules: dff, full_add

verilog is verilog dir

GAME PLAN

1. TOP DOWN ASPECT
We start with golden0.v . This is the highest level expression of the project possible.
We then move to golden1.v -> golden2.v etc as we make verilog versions of the submodules
and plug them in to verilog project. Ideally we will have a test bench that works against
golden0.v soon, and then we can test each subdivision against it. 

2. BOTTOM UP ASPECT
While some fuck ass is doing this verilog shenanigans, the other/others can make .v modules
and then the corresponding schematic and test against it. Here are the things we need. 
* denote things to do [] denote what comes after it.

    dff -> *dff_en* -> [reg1-5] (not hard, shown on proj description, input and output enables)
    *and_en* -> [ppgen] (also not hard, shown on schematic. Its a fucking and with output enable)
    *shift* -> [log_shifter] (ehh not sure how to break this down. One person is pretty 
                              much going to own the whole shifter portion of the project)
    
    [rca] the adder i do not think needs anything fancy since it is ripple carry

    FINITE STATE MACHINE
    	   *counter*, *crazy shit*
    kind of like the shifter, somebody is going to own this mother fucker.

IS THIS A GOOD PLAN
   not sure, but i wrote it down anyway. Mostly im trying to go off of what I learned from
   nvidia. They do roughly this, with architects doing verilog from top to bottom and layout
   doing what they can before they get a final netlist.
   	 arch -> netlist -> masks
